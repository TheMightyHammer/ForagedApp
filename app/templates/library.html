<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Bayleaf</title>
    <link rel="stylesheet" href="{{ request.url_for('static', path='app.css') }}" />
    <link rel="icon" href="{{ request.url_for('static', path='favicon.ico') }}">
    <meta name="theme-color" content="#5F7A6A" />
  </head>
  <body>
    <div class="container">
      <div class="topbar">
        <div class="brandline">
          <div class="brand">
            <img
              src="{{ request.url_for('static', path='Bayleaf_Logo.png') }}"
              alt="Bayleaf logo"
              class="brand-logo"
            />
            <h1>Bayleaf</h1>
          </div>
          <div class="meta">
            {% if total %}{{ total }} book{% if total != 1 %}s{% endif %}{% else %}No books yet{% endif %}
          </div>
        </div>

        <form class="searchrow" method="get" action="{{ request.url_for('home') }}">
          <div class="searchpill">
            <input
              type="text"
              name="q"
              value="{{ q or '' }}"
              placeholder="Search"
              autocomplete="off"
            />
          </div>

          <div class="selectpill" aria-label="Sort">
            <select name="sort" id="sort" aria-label="Sort">
              <option value="title" {% if sort == 'title' %}selected{% endif %}>Title</option>
              <option value="author" {% if sort == 'author' %}selected{% endif %}>Author</option>
              <option value="year" {% if sort == 'year' %}selected{% endif %}>Publication year</option>
            </select>
          </div>

          <button id="reindexBtn" class="reindex-btn" type="button" title="Re-scan the library">
            Re-scan Library
          </button>
          <span id="reindexStatus" class="reindex-status" aria-live="polite"></span>

          <a class="pillbtn" href="{{ request.url_for('recipes') }}">Recipes</a>
          <button class="pillbtn" type="submit">Search</button>
        </form>
  
      </div>
      

      {% if notice %}
        <div class="notice">{{ notice }}</div>
      {% endif %}

      {% if not cookbooks %}
        <div class="empty">
          No cookbooks found. Check your library mount and that it contains .epub or .pdf files.
        </div>
      {% else %}
        <div class="grid">
          {% for book in cookbooks %}
            <a
              class="card-link"
              href="/read?path={{ book.rel_path|urlencode }}"
              target="_blank"
              rel="noopener"
              title="Open reader"
            >
              <div
                class="card"
                data-name="{{ (book.name or '')|e }}"
                data-author="{{ (book.author or '')|e }}"
                data-year="{{ (book.published_year or '')|e }}"
                data-rel-path="{{ (book.rel_path or '')|e }}"
                data-suffix="{{ (book.suffix or '')|e }}"
                data-cover-url="{{ (book.cover_url or '')|e }}"
              >
                <div class="cover">
                  {% set cover_src = book.cover_url or request.url_for('cover', rel_path=book.rel_path) %}
                  <img
                    src="{{ cover_src }}"
                    alt="Cover for {{ book.name }}"
                    loading="lazy"
                    class="cover-img"
                    onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                  />
                  <div class="placeholder" style="display:none;">No cover yet</div>
                </div>

                <div class="card-cta card-cta--stack">
                  <button class="btn read-btn" type="button">Read book</button>
                  {% if (book.suffix or '')|lower == '.epub' %}
                    <button class="btn reextract-btn" type="button" data-default-label="Re-extract recipes">
                      Re-extract recipes
                    </button>
                  {% endif %}
                </div>
              </div>
            </a>
          {% endfor %}
        </div>
      {% endif %}
    </div>
    <script>
      const input = document.querySelector('input[name="q"]');
      const sortSelect = document.querySelector('select[name="sort"]');
      const grid = document.querySelector('.grid');

      // Client-side filter + sort for reviewing the books currently loaded on the page.
      // This keeps "Search" (form submit) as an explicit action, while typing and sort changes act as filters.
      if (input && grid) {
        function esc(s) {
          return (s || "").replace(/[&<>"']/g, (c) => ({
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#39;",
          }[c]));
        }

        function norm(s) {
          return (s || "").toString().toLowerCase();
        }

        // Capture the initial shelf as our source of truth for filtering.
        const initialCards = Array.from(grid.querySelectorAll('.card'));
        const allBooks = initialCards.map((el) => ({
          name: el.dataset.name || el.querySelector('.title')?.textContent?.trim() || "",
          author: el.dataset.author || "",
          year: el.dataset.year || "",
          rel_path: el.dataset.relPath || "",
          suffix: el.dataset.suffix || "",
          cover_url: el.dataset.coverUrl || "",
        }));

        function cardHTML(b) {
          const name = b.name || b.rel_path || "";
          const author = b.author || "";
          const year = b.year || "";
          const relPath = b.rel_path || "";
          const suffix = (b.suffix || "").toLowerCase();
          const showReextract = suffix === ".epub";
          // Use encodeURI so path separators remain intact if relPath contains subfolders.
          const coverSrc = b.cover_url || (relPath ? `/cover/${encodeURI(relPath)}` : "");
          const readerHref = relPath ? `/read?path=${encodeURIComponent(relPath)}` : "#";

          return `
            <a class="card-link" href="${readerHref}" target="_blank" rel="noopener" title="Open reader">
              <div class="card" data-rel-path="${esc(relPath)}" data-suffix="${esc(suffix)}" data-name="${esc(name)}">
                <div class="cover">
                  <img
                    src="${coverSrc}"
                    alt="Cover for ${esc(name)}"
                    loading="lazy"
                    class="cover-img"
                    onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';"
                  />
                  <div class="placeholder" style="display:none;">No cover yet</div>
                </div>

                <div class="card-cta card-cta--stack">
                  <button class="btn read-btn" type="button">Read book</button>
                  ${
                    showReextract
                      ? `<button class="btn reextract-btn" type="button" data-default-label="Re-extract recipes">Re-extract recipes</button>`
                      : ""
                  }
                </div>
              </div>
            </a>
          `;
        }

        function sortBooks(books, sortKey) {
          const key = sortKey || 'title';
          const sorted = [...books];

          if (key === 'author') {
            sorted.sort((a, b) => norm(a.author || a.name).localeCompare(norm(b.author || b.name)));
            return sorted;
          }

          if (key === 'year') {
            // Newest first. Missing years go to the end.
            const ay = (x) => {
              const n = parseInt(x.year, 10);
              return Number.isFinite(n) ? n : -Infinity;
            };
            sorted.sort((a, b) => ay(b) - ay(a) || norm(a.name).localeCompare(norm(b.name)));
            return sorted;
          }

          // Default: title
          sorted.sort((a, b) => norm(a.name).localeCompare(norm(b.name)));
          return sorted;
        }

        function filterBooks(books, qRaw) {
          const q = (qRaw || '').trim();
          if (q.length < 3) return books;
          const nq = norm(q);
          return books.filter((b) => {
            const hay = `${norm(b.name)} ${norm(b.author)} ${norm(b.year)}`;
            return hay.includes(nq);
          });
        }

        function render(books) {
          if (!books.length) {
            grid.innerHTML = `<div class="empty">No matches.</div>`;
            return;
          }
          grid.innerHTML = books.map(cardHTML).join('');
          bindReextractButtons();
        }

        async function runReextract(relPath, title, btn) {
          if (!relPath) return;
          const statusEl = document.getElementById("reindexStatus");
          const defaultLabel = btn?.dataset?.defaultLabel || btn?.textContent || "Re-extract recipes";
          if (btn) {
            btn.disabled = true;
            btn.textContent = "Re-extracting…";
          }
          if (statusEl) {
            statusEl.textContent = `Re-extracting recipes for ${title || relPath}…`;
          }
          try {
            const res = await fetch(`/admin/reextract-recipes?path=${encodeURIComponent(relPath)}`, {
              method: "POST",
            });
            if (!res.ok) {
              const txt = await res.text();
              throw new Error(txt || `HTTP ${res.status}`);
            }
            const data = await res.json();
            if (data.error) {
              if (statusEl) statusEl.textContent = data.error;
            } else if (statusEl) {
              const count = data.extracted ?? 0;
              statusEl.textContent = `Re-extracted ${count} recipe${count === 1 ? "" : "s"} for ${title || relPath}.`;
            }
          } catch (err) {
            if (statusEl) statusEl.textContent = "Re-extract failed. Check logs.";
            console.error(err);
          } finally {
            if (btn) {
              btn.disabled = false;
              btn.textContent = defaultLabel;
            }
          }
        }

        function bindReextractButtons() {
          const buttons = Array.from(grid.querySelectorAll('.reextract-btn'));
          buttons.forEach((btn) => {
            if (btn.dataset.bound === "1") return;
            btn.dataset.bound = "1";
            btn.addEventListener('click', (event) => {
              event.preventDefault();
              event.stopPropagation();
              const card = btn.closest('.card');
              const relPath = card?.dataset?.relPath || "";
              const title = card?.dataset?.name || relPath || "book";
              runReextract(relPath, title, btn);
            });
          });
        }

        function apply() {
          const sort = sortSelect ? (sortSelect.value || 'title') : 'title';
          const qRaw = input.value || '';
          const filtered = filterBooks(allBooks, qRaw);
          const sorted = sortBooks(filtered, sort);
          render(sorted);
        }

        let t = null;
        function scheduleApply() {
          clearTimeout(t);
          t = setTimeout(apply, 120);
        }

        input.addEventListener('input', scheduleApply);
        if (sortSelect) sortSelect.addEventListener('change', apply);

        // Ensure initial render respects current sort even with empty query.
        apply();
      }

      const reindexBtn = document.getElementById("reindexBtn");
      const reindexStatus = document.getElementById("reindexStatus");

      async function runReindex() {
        try {
          reindexBtn.disabled = true;
          reindexStatus.textContent = "Reindexing…";

          const res = await fetch("/admin/reindex", { method: "POST" });
          if (!res.ok) {
            const txt = await res.text();
            throw new Error(txt || `HTTP ${res.status}`);
          }

          const data = await res.json();
          const books = data.indexed_books ?? "?";
          const recipes = data.indexed_recipes ?? "?";
          if (data.error) {
            const dir = data.library_dir || "unknown";
            reindexStatus.textContent = `${data.error}. Library dir: ${dir}`;
          } else {
            const epubs = data.epub_count ?? "?";
            reindexStatus.textContent = `Indexed ${books} books and ${recipes} recipes. EPUBs: ${epubs}. Refreshing…`;
          }

          // Reload the page so the server-rendered shelf matches DB state
          window.location.reload();
        } catch (err) {
          reindexStatus.textContent = "Reindex failed. Check logs.";
          console.error(err);
        } finally {
          reindexBtn.disabled = false;
        }
      }

      reindexBtn?.addEventListener("click", runReindex);
    </script>
  </body>
</html>
